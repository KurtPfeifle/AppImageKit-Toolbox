.\" Automatically generated by Pandoc 1.19.2.4
.\"
.TH "APPIMAGE" "1" "2017\-11\-21" "Manual Page Version 0.0.1" "AppImage Overview Manual for Version 2017/11"
.hy
.SH Name
.PP
AppImage \-\- An implementation of the AppDir concept as a single
compressed file in order to advance this idea to the "1 application = 1
file" stage (and even to "Several applications = 1 file").
.SH Synopsis
.PP
An AppImage is a compressed AppDir.
(See \f[C]man\ AppDir\f[] for details about the latter.) However, it is
not simply just compressed, but additionally contains very small
"AppRun" and "runtime" binaries which work together to execute the
AppDir payload application(s) residing inside:
.IP \[bu] 2
The runtime creates a temporary mountpoint and FUSE\-mounts the payload
AppDir.
.IP \[bu] 2
The AppRun serves as a proxy that invokes the payload application from
the AppDir.
.PP
The AppRun can be either a "standard" binary provided by the AppImageKit
set of tools.
Or it can be a custom utility (even implemented as a shell script) which
applies some additional magic when invoking the payload, such as
implementing additional command line parameters and switches for the
AppImage it is responsible for.
This could be to invoke the display of a man page for the payload
application for example.
How this is exactly done is up to the packager of the AppImage.
.PP
An AppImage is never uncompressed when it runs: it is only mounted
(using FUSE) to an automatically created mountpoint temporarily from
where its AppDir payload is executed.
As an AppImage, its internal contents cannot be changed, they are
read\-only.
.PP
However, you can extract any AppImage with the command
\f[C]"./<whatever>.AppImage\ \-\-appimage\-extract"\f[].
This will create a writable AppDir which also lets you also execute its
payload, but now you can additionally modify its content.
This is useful if you want to debug a problem within the original
AppImage or want to modify or fix it before you finally re\-package it
back into a modified/fixed AppImage.
.SH Main Features
.PP
An AppImage implements the fundamental, simple and beautiful software
design philosphy of "One application == One file".
(It can even realize the idea of "Several applications == One file".)
.PP
An AppImage lets you store any application in as small an amount of disk
space as you can imagine, while at the same time keeping its software
payload fully functional.
.PP
An AppImage can be run...
.IP "1." 3
from any location on a disk,
.IP "2." 3
from any externally connected storage device (such as an USB
thumbdrive),
.IP "3." 3
from any remotely mounted computer (for example an "sshfs" file system)
or
.IP "4." 3
even via a shared directory on the network.
.PP
An AppImage...
.IP "1." 3
can be renamed to any other name,...
.IP "2." 3
does not rely on the \f[I]\f[C]\&.AppImage\f[]\f[] filename extension
.IP "3." 3
and runs even through a symlink pointing to it.
.PP
An AppImage does not need root privileges to run \-\- it does not even
need to "install".
Just download it and run (after making it executable).
.PP
An AppImage does not mess with your base system libraries (because it
does not "install").
.PP
An AppImage does not conflict with files installed and controlled by
your local package management system (such as APT, RPM, YUM, ZYPPER,
SMART or whatever they may be called).
.PP
An AppImage for any software \[aq]XYZ\[aq] can run side\-by\-side with
the system\-installed software \[aq]XYZ\[aq] (or with another
\[aq]XYZ\[aq]\-AppImage) without any interference, even if their
versions are very different.
.PP
An AppImage for software \[aq]ABC\[aq] is an excellent tool to make
available pre\-releases for beta\-testing to the community of your own
QA, translator, artist and other contributors and users.
.PP
An AppImage can be made for any kind of Linux software, be it Free and
Libre Open Source Software or closed source / proprietary software.
.PP
An AppImage is the quickest and most hassle\-free way for users of any
Linux distro to test (and even permanently run) a software that is not
available in the repository and stores of their distro of choice.
.PP
An AppImage is the least work for packagers to do if they want to
distribute working binaries of a software to as wide an audience as
possible.
.PP
An AppImage gives back control to upstream developers of any software
over one major distribution channel: because they can always host their
own AppImage on systems under their own control, sign it with their own
GPG keys and make it their only "official" releases, taking away the
gatekeepers and middlemen and Distro package policies which may disallow
the distribution of "bleeding edge" software.
.PP
An AppImage is the best way to bring initially released (or newly
updated) software onto any systems which have it not available thru
their official channels.
.PP
An AppImage can be automatically integrated into desktop environments
and the start menus of most systems by running the optional
\f[B]\f[C]appimaged\f[]\f[] (AppImage Daemon) on the system.
.PP
An AppImage is easily created automatically if the software\[aq]s source
code is hosted on GitHub and if the automatic building of its binaries
is enabled through Travice CI (Continuous Integration).
.PP
An AppImage can also be automatically and easily created through the
Open Build Service (OBS) of openSUSE.
.PP
An AppImage can be created through different ways:
.IP "(1)" 4
Convert an existing binary package (such as DEB or RPM or TGZ).
.IP "(2)" 4
Bundle automatically GitHub / Travis CI builds as AppImage.
.IP "(3)" 4
Use \f[I]`\f[C]linuxdeployqt\f[]\f[] for your Qt or non\-Qt application.
.IP "(4)" 4
Use \f[I]\f[C]electron\-builder\f[]\f[] for Electron apps.
.IP "(5)" 4
Manually build an AppDir and run \f[I]\f[C]appimagetool\f[]\f[] against
it.
.IP "(6)" 4
Completely build your own AppImage from scratch by following the current
AppImage specification (see below).
.PP
An AppImage can be made to self\-update using the AppImageUpdate GUI
utility or the \f[C]appimageupdatetool\f[] CLI tool.
Both these are great in so far as theiy will not download all the bytes
for a completely new AppImage version.
Instead they fetch only the binary "delta" of bytes and patch the
previous AppImage to a new one.
This saves bandwidth, space and time for the end users as well as for
the hosting service.
.SH Dog food
.PP
AppImage developers like to \f[I]"eat their own dog food"\f[]: They
provide all their tools pre\-compiled as AppImages, and they use
AppImage\-d binaries of their own tools in many of their automatic
Travis CI build processes.
.SH Main Features
.SH Benefits for Developers
.SH Benefits for End Users
.SH Scope
.SH Description of Tools
.SH Examples
.SH History
.SH Current and Future Work
.SH Specification
.SH Code
.SH IRC
.PP
The AppImage developers can be met online in IRC at Freenode in channel
#AppImage.
.SH Bugs
.SH Bug Tracker
.SH Wiki
.SH List of available AppImage\-d Software
.SH Homepage
.SH See Also
.PP
AppImage\-AppDir(7), AppImage\-AppImage(1), AppImage\-AppImageKit(7),
AppImage\-AppImageUpdate(1), AppImage\-AppRun(7), AppImage\-FAQ(7),
AppImage\-appimaged(1), AppImage\-appimagetool(1),
AppImage\-linuxdeployqt(1), AppImage\-payload(7)
AppImage\-pkg2appimage(1), AppImage\-runtime(7), AppImage\-validate(1),
AppImage\-zsync2(1), AppImage\-zsyncmake2(1).
.SH Developers
.PP
AppImageKit is developed by Simon Peter (<probono@puredarwin.org>) and
others.
.SH Author
.PP
This manual page was written by Kurt Pfeifle (<kurt.pfeifle@gmail.com>)
for the AppImage Project.
